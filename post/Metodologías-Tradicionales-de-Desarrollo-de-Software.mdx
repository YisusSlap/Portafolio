---
title: "Metodolog칤as Tradicionales de Desarrollo de Software 游꿉"
date: "2024-08-22"
description: "Descripci칩n y an치lisis de las metodolog칤as tradicionales de desarrollo de software, incluyendo Cascada, Prototipos, Espiral, Win-Win, Basado en Componentes y Concurrente."
---
# Metodolog칤as Tradicionales o Prescriptivas

### Cascada
El modelo de proceso de desarrollo de software m치s antiguo publicado (Royce, 1970). Se conoce como ciclo de vida del software.

#### Cr칤ticas:
- Los proyectos reales rara vez se ajustan perfectamente al modelo.
- Es com칰n que el cliente no exponga todos los requerimientos desde el inicio.
- El producto operativo solo se entrega al final del proceso.

#### Consejo:
- 칔til para proyectos donde los requisitos est치n bien definidos desde el principio y no se espera que cambien.

### Prototipos
Es un modelo a escala que representa c칩mo podr칤a ser el producto final, pero no es equivalente a este. Iniciado por la psic칩loga Eleanor Rosch y m치s tarde adoptado por Hasan Gomaa (1984).

#### Lineamientos del desarrollo:
- Trabajar en m칩dulos manejables.
- Construir el prototipo r치pidamente.
- Involucrar al cliente en la evaluaci칩n temprana y continua del prototipo.

#### Ventajas:
- Permite identificar la viabilidad del sistema en etapas tempranas.
- Facilita la incorporaci칩n de cambios en las primeras etapas del desarrollo.

#### Desventajas:
- Posible modificaci칩n constante del prototipo, lo que puede alterar funcionalidades o caracter칤sticas.
- El cliente puede confundir el prototipo con el sistema final.
- Riesgo de familiarizarse con decisiones iniciales equivocadas.

#### Consejo:
- 칔til cuando los requerimientos no est치n claramente definidos desde el inicio.
- Es esencial establecer de antemano las expectativas y las reglas del juego con el cliente.

### Modelo Evolutivo
Se adapta m치s f치cilmente a los cambios introducidos a lo largo del desarrollo. Es iterativo, y en cada iteraci칩n se obtiene una versi칩n m치s completa del software. Algunos modelos evolutivos son el espiral y el Win-Win.

### Espiral
Propuesto por Barry Boehm en 1986. Tiene un enfoque c칤clico donde cada ciclo representa una fase del proceso de desarrollo de software. Es 칰til para proyectos grandes y permite el uso de prototipos.

#### Cr칤ticas:
- Es dif칤cil convencer a los clientes de que es un modelo controlable.
- Requiere habilidades avanzadas para el an치lisis de riesgos.

#### Etapas:
1. **Planeaci칩n:** Determinaci칩n de objetivos, alternativas y restricciones.
2. **An치lisis de riesgos:** Identificaci칩n y mitigaci칩n de riesgos.
3. **Ingenier칤a:** Desarrollo y verificaci칩n del producto.
4. **Evaluaci칩n:** Valoraci칩n por parte del cliente de los resultados obtenidos.

#### Ventajas:
- Combina los mejores elementos de otros modelos.
- Reduce significativamente los riesgos del proyecto.

#### Desventajas:
- Puede aumentar el tiempo de desarrollo.
- Genera costos elevados.

### Win-Win
Desarrollado por Barry Boehm en 1988, basado en la teor칤a de Administraci칩n de Sistemas. Inicia con una negociaci칩n en cada fase del modelo espiral.

#### Fases:
1. Identificaci칩n de los actores del sistema.
2. Determinaci칩n de las condiciones de "ganar" para cada parte interesada.
3. Negociaciones para asegurar un acuerdo que beneficie a todas las partes.

#### Ventajas:
- Acelera la producci칩n de software.
- Establece claramente los objetivos del proyecto.

#### Desventajas:
- Requiere una alta habilidad de negociaci칩n y manejo de conflictos.

### Basado en Componentes
Este modelo est치 muy relacionado con la programaci칩n orientada a objetos. Iniciado por Garnisch en Alemania (1968) con su discurso titulado "Mass Produced Software Component".

#### Ventajas:
- El c칩digo de las clases es reutilizable dentro del mismo software que se va creando.
- Acelera la creaci칩n de software (entre un 70% y 80% m치s r치pido).
- Simplifica las pruebas al realizarlas por componentes, asegurando un producto final de calidad.

#### Desventajas:
- Depende en gran medida de haber creado una biblioteca de clases bien dise침ada.

### Concurrente
Atribuido a Davis Sitaram, tambi칠n conocido como Ingenier칤a Concurrente. Este modelo es aplicable a todo tipo de desarrollo de software. Cada actividad, acci칩n o tarea puede ocurrir simult치neamente con otras.

#### Ventajas:
- Recomendado para proyectos con grupos de trabajo independientes.
- Proporciona una imagen precisa del estado actual del proyecto.

#### Desventajas:
- No es viable si no existen grupos de trabajo independientes.
